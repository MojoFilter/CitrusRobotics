// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: RobotContainer.

package frc.robot;

import frc.robot.commands.*;
import frc.robot.subsystems.*;
import frc.robot.util.Rumbler;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.Command.InterruptionBehavior;

import java.util.*;

import edu.wpi.first.networktables.*;
import edu.wpi.first.wpilibj.shuffleboard.*;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj2.command.button.JoystickButton;
import frc.robot.subsystems.*;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 * This class is where the bulk of the robot should be declared. Since
 * Command-based is a
 * "declarative" paradigm, very little robot logic should actually be handled in
 * the {@link Robot}
 * periodic methods (other than the scheduler calls). Instead, the structure of
 * the robot
 * (including subsystems, commands, and button mappings) should be declared
 * here.
 */
public class RobotContainer {

  private static RobotContainer m_robotContainer = new RobotContainer();

  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
  // The robot's subsystems
  public final SoundBoard m_soundBoard = new SoundBoard();
  public final DriveTrain m_driveTrain = new DriveTrain();

  // Joysticks
  private final XboxController xboxController1 = new XboxController(0);

  // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

  private final Rumbler rumbler = new Rumbler();

  // A chooser for autonomous commands
  SendableChooser<Command> m_chooser = new SendableChooser<>();

  private GenericEntry speedGovernorSource;
  private SendableChooser<Command> driveModeChooser = new SendableChooser<>();
  private Command currentDriveCommand;

  /**
   * The container for the robot. Contains subsystems, OI devices, and commands.
   */
  private RobotContainer() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SMARTDASHBOARD
    // Smartdashboard Subsystems
    SmartDashboard.putData(m_soundBoard);
    SmartDashboard.putData(m_driveTrain);

    // SmartDashboard Buttons
    SmartDashboard.putData("Twist", new Twist(m_driveTrain));
    SmartDashboard.putData("Play Startup Command", new PlayStartupCommand(m_soundBoard));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SMARTDASHBOARD
    // Configure the button bindings
    configureButtonBindings();

    // Configure default commands
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SUBSYSTEM_DEFAULT_COMMAND
    m_driveTrain.setDefaultCommand(new ArcadeDrive(() -> -getXboxController1().getRawAxis(1),
        () -> -getXboxController1().getRawAxis(4), "Split", "B260:100 P260 B260:100", m_driveTrain));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SUBSYSTEM_DEFAULT_COMMAND

    // Configure autonomous sendable chooser
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

    m_chooser.addOption("Autonomous Command", new AutonomousCommand(m_driveTrain));
    m_chooser.setDefaultOption("Autonomous Command", new AutonomousCommand(m_driveTrain));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

    SmartDashboard.putData("Auto Mode", m_chooser);
    configureDashboard();
  }

  private void configureDashboard() {
    ShuffleboardTab driveTab = Shuffleboard.getTab("Drive");

    this.speedGovernorSource = driveTab.add("Speed Governor", 0.65)
        .withWidget(BuiltInWidgets.kNumberSlider)
        .withProperties(Map.of("min", 0, "max", 1))
        .withSize(3, 1)
        .getEntry();

    driveTab.add(m_driveTrain.getField())
        .withSize(6, 4)
        .withPosition(3, 0);

    driveTab.add(m_driveTrain.getDrive())
        .withPosition(0, 2);

    /*
     * driveTab.add("Field Approximation", m_driveTrain.getFieldApproximation())
     * .withSize(6,4)
     * .withPosition(3, 4);
     */

    Command arcadeSplitCommand = new ArcadeDrive(
        () -> -getXboxController1().getRawAxis(1),
        () -> -getXboxController1().getRawAxis(4),
        "Split",
        "B260:100 P260 B260:100",
        m_driveTrain)
        .withInterruptBehavior(InterruptionBehavior.kCancelSelf);

    Command arcade1StickCommand = new ArcadeDrive(
        () -> -getXboxController1().getRawAxis(1),
        () -> -getXboxController1().getRawAxis(0),
        "1-Stick",
        "B500:100",
        m_driveTrain)
        .withInterruptBehavior(InterruptionBehavior.kCancelSelf);

    Command tankDriveCommand = new TankDrive(
        () -> -getXboxController1().getRawAxis(1),
        () -> -getXboxController1().getRawAxis(5),
        m_driveTrain)
        .withInterruptBehavior(InterruptionBehavior.kCancelSelf);

    this.currentDriveCommand = arcadeSplitCommand;
    this.driveModeChooser.setDefaultOption("Arcade Split", arcadeSplitCommand);
    this.driveModeChooser.addOption("Arcade 1-Stick", arcade1StickCommand);
    this.driveModeChooser.addOption("Tank Drive", tankDriveCommand);
    driveTab.add("Drive Mode", this.driveModeChooser)
        .withPosition(0, 1)
        .withSize(3, 1);

    Shuffleboard.selectTab("Drive");
  }

  public static RobotContainer getInstance() {
    return m_robotContainer;
  }

  /**
   * Use this method to define your button->command mappings. Buttons can be
   * created by
   * instantiating a {@link GenericHID} or one of its subclasses ({@link
   * edu.wpi.first.wpilibj.Joystick} or {@link XboxController}), and then passing
   * it to a
   * {@link edu.wpi.first.wpilibj2.command.button.JoystickButton}.
   */
  private void configureButtonBindings() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=BUTTONS
    // Create some buttons
    final JoystickButton twistButton = new JoystickButton(xboxController1, 8);
    twistButton.onTrue(new Twist(m_driveTrain).withInterruptBehavior(InterruptionBehavior.kCancelSelf));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=BUTTONS

  }

  public void rumble(String rumblePattern) {
    this.rumbler.rumble(this.getXboxController1(), rumblePattern);
  }

  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS
  public XboxController getXboxController1() {
    return xboxController1;
  }

  // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS

  /**
   * Use this to pass the autonomous command to the main {@link Robot} class.
   *
   * @return the command to run in autonomous
   */
  public Command getAutonomousCommand() {
    // The selected command will be run in autonomous
    return m_chooser.getSelected();
  }

  public void resetIO(boolean announce) {
    m_soundBoard.reset();
    if (announce) {
      new PlayStartupCommand(m_soundBoard).schedule();
    }
  }

  public void playTankDrive() {
    m_soundBoard.playTankDrive();
  }

  public void playArcade1Stick() {
    m_soundBoard.playArcade1Stick();
  }

  public void playArcadeSplit() {
    m_soundBoard.playArcadeSplit();
  }

  public double getSpeedGovernor() {
    return this.getXboxController1().getRightTriggerAxis() > 0.9 ? 1.0
        : this.speedGovernorSource.getDouble(Constants.DriveTrain.DefaultSpeedGovernor);
  }

  public void updateDriveMode() {
    var selectedCommand = this.driveModeChooser.getSelected();
    if (selectedCommand != this.currentDriveCommand) {
      this.currentDriveCommand = selectedCommand;
      this.currentDriveCommand.schedule();
    }
  }
}
