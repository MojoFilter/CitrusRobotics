// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import frc.robot.Constants;
import frc.robot.RobotContainer;
import frc.robot.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.wpilibj.simulation.*;
import edu.wpi.first.wpilibj.simulation.DifferentialDrivetrainSim.KitbotGearing;
import edu.wpi.first.wpilibj.simulation.DifferentialDrivetrainSim.KitbotMotor;
import edu.wpi.first.wpilibj.simulation.DifferentialDrivetrainSim.KitbotWheelSize;
import edu.wpi.first.wpilibj.smartdashboard.Field2d;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import java.io.IOException;
import java.text.SimpleDateFormat;

import org.photonvision.PhotonCamera;
import org.photonvision.SimVisionSystem;

import edu.wpi.first.apriltag.AprilTagFieldLayout;
import edu.wpi.first.apriltag.AprilTagFields;
import edu.wpi.first.math.ComputerVisionUtil;
import edu.wpi.first.math.VecBuilder;
import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.math.controller.SimpleMotorFeedforward;
import edu.wpi.first.math.estimator.DifferentialDrivePoseEstimator;
import edu.wpi.first.math.geometry.*;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.kinematics.DifferentialDriveOdometry;
import edu.wpi.first.math.kinematics.DifferentialDriveWheelSpeeds;
import edu.wpi.first.math.util.Units;
import edu.wpi.first.networktables.DoubleArrayEntry;
import edu.wpi.first.networktables.IntegerEntry;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.wpilibj.*;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.motorcontrol.MotorController;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;
import edu.wpi.first.wpilibj.motorcontrol.PWMVictorSPX;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class DriveTrain extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private PWMVictorSPX left1;
    private PWMVictorSPX left2;
    private MotorControllerGroup leftController;
    private PWMVictorSPX right1;
    private PWMVictorSPX right2;
    private MotorControllerGroup rightController;
    private DifferentialDrive drive;
    private Encoder leftEncoder;
    private Encoder rightEncoder;
    private AnalogGyro gyro;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private final PhotonCamera targetCam;

    private DifferentialDriveOdometry odometry;
    private final SimpleMotorFeedforward feedforward;
    private final DifferentialDrivePoseEstimator poseEstimator;

    private final PIDController leftPIDController;
    private final PIDController rightPIDController;

    private Field2d field;
    private Field2d fieldApproximation;

    private final AprilTagFieldLayout fieldTags;

    private EncoderSim leftEncoderSim;
    private EncoderSim rightEncoderSim;
    private AnalogGyroSim gyroSim;
    private DifferentialDrivetrainSim driveSim;
    private final SimVisionSystem visionSim;

    private final IntegerEntry currentTargetEntry;

    /**
    *
    */
    public DriveTrain() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        left1 = new PWMVictorSPX(0);
        addChild("Left 1", left1);
        left1.setInverted(false);

        left2 = new PWMVictorSPX(1);
        addChild("Left 2", left2);
        left2.setInverted(false);

        leftController = new MotorControllerGroup(left1, left2);
        addChild("Left Controller", leftController);

        right1 = new PWMVictorSPX(2);
        addChild("Right 1", right1);
        right1.setInverted(false);

        right2 = new PWMVictorSPX(3);
        addChild("Right 2", right2);
        right2.setInverted(false);

        rightController = new MotorControllerGroup(right1, right2);
        addChild("Right Controller", rightController);

        drive = new DifferentialDrive(leftController, rightController);
        addChild("Drive", drive);
        drive.setSafetyEnabled(true);
        drive.setExpiration(0.1);
        drive.setMaxOutput(1.0);

        leftEncoder = new Encoder(0, 1, false, EncodingType.k4X);
        addChild("Left Encoder", leftEncoder);
        leftEncoder.setDistancePerPulse(1.0);

        rightEncoder = new Encoder(2, 3, false, EncodingType.k4X);
        addChild("Right Encoder", rightEncoder);
        rightEncoder.setDistancePerPulse(1.0);

        gyro = new AnalogGyro(0);
        addChild("Gyro", gyro);
        gyro.setSensitivity(0.007);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        this.leftEncoderSim = new EncoderSim(this.leftEncoder);
        this.rightEncoderSim = new EncoderSim(this.rightEncoder);
        this.gyroSim = new AnalogGyroSim(gyro);
        this.driveSim = DifferentialDrivetrainSim.createKitbotSim(
                KitbotMotor.kDualCIMPerSide,
                KitbotGearing.k10p71,
                KitbotWheelSize.kSixInch,
                null);
        this.visionSim = new SimVisionSystem(
                Constants.Vision.TargetCameraName,
                Constants.Vision.TargetCameraFOVDegrees,
                Constants.Vision.RobotToTargetCamera,
                Constants.Vision.TargetCameraMaxLedRangeMeters,
                Constants.Vision.TargetCameraResolutionWidth,
                Constants.Vision.TargetCameraResolutionHeight,
                Constants.Vision.TargetCameraMinTargetArea);

        this.leftEncoder.setDistancePerPulse(Constants.DriveTrain.EncoderDistancePerPulse); // not sure what these
                                                                                            // constants should be
        this.rightEncoder.setDistancePerPulse(Constants.DriveTrain.EncoderDistancePerPulse);
        this.resetEncoders();
        this.field = new Field2d();
        this.fieldApproximation = new Field2d();

        this.odometry = new DifferentialDriveOdometry(
                Rotation2d.fromDegrees(getHeading()),
                leftEncoder.getDistance(),
                rightEncoder.getDistance());

        this.poseEstimator = new DifferentialDrivePoseEstimator(
                Constants.DriveTrain.DriveKinematics,
                this.gyro.getRotation2d(),
                this.leftEncoder.getDistance(),
                this.rightEncoder.getDistance(),
                new Pose2d(),
                VecBuilder.fill(0.05, 0.05, Units.degreesToRadians(5)),
                VecBuilder.fill(0.5, 0.5, Units.degreesToRadians(30)));

        this.feedforward = new SimpleMotorFeedforward(1, 3);
        this.leftPIDController = new PIDController(1, 0, 0);
        this.rightPIDController = new PIDController(1, 0, 0);

        try {
            this.fieldTags = AprilTagFieldLayout.loadFromResource(AprilTagFields.k2023ChargedUp.m_resourceFile);
            this.visionSim.addVisionTargets(this.fieldTags);
        } catch (IOException ioe) {
            ioe.printStackTrace();
            throw new RuntimeException();
        }

        this.targetCam = new PhotonCamera(Constants.Vision.TargetCameraName);

        var currentTargetTopic = NetworkTableInstance.getDefault().getIntegerTopic("Drive/CurrentTarget");
        this.currentTargetEntry = currentTargetTopic.getEntry(-1);
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run

        this.updateOdometry();
        this.field.setRobotPose(odometry.getPoseMeters());
        this.fieldApproximation.setRobotPose(this.poseEstimator.getEstimatedPosition());

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

        driveSim.setInputs(
                leftController.get() * RobotController.getInputVoltage(),
                rightController.get() * RobotController.getInputVoltage());

        driveSim.update(0.02);
        this.visionSim.processFrame(this.driveSim.getPose());

        leftEncoderSim.setDistance(driveSim.getLeftPositionMeters());
        leftEncoderSim.setRate(driveSim.getLeftVelocityMetersPerSecond());
        rightEncoderSim.setDistance(driveSim.getRightPositionMeters());
        rightEncoderSim.setRate(driveSim.getRightVelocityMetersPerSecond());
        gyroSim.setAngle(-driveSim.getHeading().getDegrees());
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void drive(double leftSpeed, double rightSpeed) {
        var sg = RobotContainer.getInstance().getSpeedGovernor();
        drive.tankDrive(leftSpeed * sg, rightSpeed * sg);
    }

    public void tankDriveVolts(double leftVolts, double rightVolts) {
        this.leftController.setVoltage(leftVolts);
        this.rightController.setVoltage(rightVolts);
        this.drive.feed();
    }

    public void arcadeDrive(double speed, double rotation) {
        var sg = RobotContainer.getInstance().getSpeedGovernor();
        drive.arcadeDrive(speed * sg, rotation * sg);
    }

    /**
     * Drives the robot with the given linear velocity and angular velocity.
     * 
     * @param linearSpeed Linear velocity in m/s.
     * @param rotation    Angular velocity in rad/s.
     */
    public void directDrive(double linearSpeed, double rotation) {
        var wheelSpeeds = Constants.DriveTrain.DriveKinematics
                .toWheelSpeeds(new ChassisSpeeds(linearSpeed, 0.0, rotation));
        this.setSpeeds(wheelSpeeds);
    }

    public double getHeading() {
        return Math.IEEEremainder(gyro.getAngle(), 360) * -1;
    }

    public void resetEncoders() {
        this.leftEncoder.reset();
        this.rightEncoder.reset();
    }

    public Pose2d getPose() {
        return this.odometry.getPoseMeters();
    }

    public void resetOdometry(Pose2d pose) {
        this.odometry.resetPosition(Rotation2d.fromRadians(0), 0, 0, pose);
    }

    public DifferentialDriveWheelSpeeds getWheelSpeeds() {
        return new DifferentialDriveWheelSpeeds(this.leftEncoder.getRate(), this.rightEncoder.getRate());
    }

    public DifferentialDrive getDrive() {
        return this.drive;
    }

    public Field2d getField() {
        return this.field;
    }

    public Field2d getFieldApproximation() {
        return this.fieldApproximation;
    }

    private void setSpeeds(DifferentialDriveWheelSpeeds speeds) {
        final double leftFeedforward = this.feedforward.calculate(speeds.leftMetersPerSecond);
        final double rightFeedforward = this.feedforward.calculate(speeds.rightMetersPerSecond);

        final double leftOutput = this.leftPIDController.calculate(this.leftEncoder.getRate(),
                speeds.leftMetersPerSecond);
        final double rightOutput = this.rightPIDController.calculate(this.rightEncoder.getRate(),
                speeds.rightMetersPerSecond);

        this.tankDriveVolts(leftOutput + leftFeedforward, rightOutput + rightFeedforward);
    }

    private void updateOdometry() {
        this.poseEstimator.update(
                this.gyro.getRotation2d(),
                this.leftEncoder.getDistance(),
                this.rightEncoder.getDistance());

        var visionResult = this.targetCam.getLatestResult();
        if (visionResult.hasTargets()) {
            var imageCaptureTime = visionResult.getTimestampSeconds();
            var target = visionResult.getBestTarget();
            var camToTarget = target.getBestCameraToTarget();
            var targetId = target.getFiducialId();
            var tagPose = this.fieldTags.getTagPose(targetId).get();
            var camPose = tagPose.transformBy(camToTarget.inverse());
            var botPose = camPose.transformBy(Constants.Vision.RobotToTargetCamera.inverse());
            this.poseEstimator.addVisionMeasurement(botPose.toPose2d(), imageCaptureTime);
            this.currentTargetEntry.set(targetId);
        } else {
            this.currentTargetEntry.set(-1);
        }

        this.odometry.update(this.gyro.getRotation2d(), this.leftEncoder.getDistance(),
                this.rightEncoder.getDistance());
    }
}
