// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import frc.robot.Constants;
import frc.robot.RobotContainer;
import frc.robot.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.wpilibj.simulation.*;
import edu.wpi.first.wpilibj.simulation.DifferentialDrivetrainSim.KitbotGearing;
import edu.wpi.first.wpilibj.simulation.DifferentialDrivetrainSim.KitbotMotor;
import edu.wpi.first.wpilibj.simulation.DifferentialDrivetrainSim.KitbotWheelSize;
import edu.wpi.first.wpilibj.smartdashboard.Field2d;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import java.io.IOException;
import java.text.SimpleDateFormat;

import edu.wpi.first.apriltag.AprilTagFieldLayout;
import edu.wpi.first.apriltag.AprilTagFields;
import edu.wpi.first.math.ComputerVisionUtil;
import edu.wpi.first.math.VecBuilder;
import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.math.controller.SimpleMotorFeedforward;
import edu.wpi.first.math.estimator.DifferentialDrivePoseEstimator;
import edu.wpi.first.math.geometry.*;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.kinematics.DifferentialDriveOdometry;
import edu.wpi.first.math.kinematics.DifferentialDriveWheelSpeeds;
import edu.wpi.first.math.util.Units;
import edu.wpi.first.networktables.DoubleArrayEntry;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.wpilibj.*;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.motorcontrol.MotorController;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;
import edu.wpi.first.wpilibj.motorcontrol.PWMVictorSPX;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class DriveTrain extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private PWMVictorSPX left1;
    private PWMVictorSPX left2;
    private MotorControllerGroup leftController;
    private PWMVictorSPX right1;
    private PWMVictorSPX right2;
    private MotorControllerGroup rightController;
    private DifferentialDrive drive;
    private Encoder leftEncoder;
    private Encoder rightEncoder;
    private AnalogGyro gyro;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private EncoderSim leftEncoderSim;
    private EncoderSim rightEncoderSim;
    private AnalogGyroSim gyroSim;
    private DifferentialDrivetrainSim driveSim;
    private DifferentialDriveOdometry odometry;
    private final SimpleMotorFeedforward feedforward;
    private final DifferentialDrivePoseEstimator poseEstimator;

    private final PIDController leftPIDController;
    private final PIDController rightPIDController;

    private Field2d field;
    private Field2d fieldApproximation;
    private Pose3d objectInField;

    private final DoubleArrayEntry cameraToObjectEntry;
    private final double[] cameraToObjectDefaultValue = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };

    /**
    *
    */
    public DriveTrain() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        left1 = new PWMVictorSPX(0);
        addChild("Left 1", left1);
        left1.setInverted(false);

        left2 = new PWMVictorSPX(1);
        addChild("Left 2", left2);
        left2.setInverted(false);

        leftController = new MotorControllerGroup(left1, left2);
        addChild("Left Controller", leftController);

        right1 = new PWMVictorSPX(2);
        addChild("Right 1", right1);
        right1.setInverted(false);

        right2 = new PWMVictorSPX(3);
        addChild("Right 2", right2);
        right2.setInverted(false);

        rightController = new MotorControllerGroup(right1, right2);
        addChild("Right Controller", rightController);

        drive = new DifferentialDrive(leftController, rightController);
        addChild("Drive", drive);
        drive.setSafetyEnabled(true);
        drive.setExpiration(0.1);
        drive.setMaxOutput(1.0);

        leftEncoder = new Encoder(0, 1, false, EncodingType.k4X);
        addChild("Left Encoder", leftEncoder);
        leftEncoder.setDistancePerPulse(1.0);

        rightEncoder = new Encoder(2, 3, false, EncodingType.k4X);
        addChild("Right Encoder", rightEncoder);
        rightEncoder.setDistancePerPulse(1.0);

        gyro = new AnalogGyro(0);
        addChild("Gyro", gyro);
        gyro.setSensitivity(0.007);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        this.leftEncoderSim = new EncoderSim(this.leftEncoder);
        this.rightEncoderSim = new EncoderSim(this.rightEncoder);
        this.gyroSim = new AnalogGyroSim(gyro);
        this.driveSim = DifferentialDrivetrainSim.createKitbotSim(
                KitbotMotor.kDualCIMPerSide,
                KitbotGearing.k10p71,
                KitbotWheelSize.kSixInch,
                null);

        this.leftEncoder.setDistancePerPulse(Constants.DriveTrain.EncoderDistancePerPulse); // not sure what these
                                                                                            // constants should be
        this.rightEncoder.setDistancePerPulse(Constants.DriveTrain.EncoderDistancePerPulse);
        this.resetEncoders();
        this.field = new Field2d();
        SmartDashboard.putData("Field", field);

        this.fieldApproximation = new Field2d();
        SmartDashboard.putData("FieldEstimation", this.fieldApproximation);
        
        this.odometry = new DifferentialDriveOdometry(Rotation2d.fromDegrees(getHeading()), leftEncoder.getDistance(),
                rightEncoder.getDistance());

        this.poseEstimator = new DifferentialDrivePoseEstimator(
                Constants.DriveTrain.DriveKinematics,
                this.gyro.getRotation2d(),
                this.leftEncoder.getDistance(),
                this.rightEncoder.getDistance(),
                new Pose2d(),
                VecBuilder.fill(0.05, 0.05, Units.degreesToRadians(5)),
                VecBuilder.fill(0.5, 0.5, Units.degreesToRadians(30)));

        this.feedforward = new SimpleMotorFeedforward(1, 3);
        this.leftPIDController = new PIDController(1, 0, 0);
        this.rightPIDController = new PIDController(1, 0, 0);

        try {
            var fieldLayout = AprilTagFieldLayout.loadFromResource(AprilTagFields.k2023ChargedUp.m_resourceFile);
            this.objectInField = fieldLayout.getTagPose(0).get();
        } catch (IOException ioe) {
            ioe.printStackTrace();
            throw new RuntimeException();
        }

        var cameraToObjectTopic = NetworkTableInstance.getDefault().getDoubleArrayTopic("cameraToObject");
        this.cameraToObjectEntry = cameraToObjectTopic.getEntry(this.cameraToObjectDefaultValue);
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run

        this.updateOdometry();
        field.setRobotPose(odometry.getPoseMeters());

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

        driveSim.setInputs(
            leftController.get() * RobotController.getInputVoltage(),
            rightController.get() * RobotController.getInputVoltage());

        driveSim.update(0.02);

        leftEncoderSim.setDistance(driveSim.getLeftPositionMeters());
        leftEncoderSim.setRate(driveSim.getLeftVelocityMetersPerSecond());
        rightEncoderSim.setDistance(driveSim.getRightPositionMeters());
        rightEncoderSim.setRate(driveSim.getRightVelocityMetersPerSecond());
        gyroSim.setAngle(-driveSim.getHeading().getDegrees());
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void drive(double leftSpeed, double rightSpeed) {
        var sg = RobotContainer.getInstance().getSpeedGovernor();
        drive.tankDrive(leftSpeed * sg, rightSpeed * sg);
    }

    public void tankDriveVolts(double leftVolts, double rightVolts) {
        this.leftController.setVoltage(leftVolts);
        this.rightController.setVoltage(rightVolts);
        this.drive.feed();
    }

    public void arcadeDrive(double speed, double rotation) {
        var sg = RobotContainer.getInstance().getSpeedGovernor();
        drive.arcadeDrive(speed * sg, rotation * sg);
    }

    public double getHeading() {
        return Math.IEEEremainder(gyro.getAngle(), 360) * -1;
    }

    public void resetEncoders() {
        this.leftEncoder.reset();
        this.rightEncoder.reset();
    }

    public Pose2d getPose() {
        return this.odometry.getPoseMeters();
    }

    public void resetOdometry(Pose2d pose) {
        this.odometry.resetPosition(Rotation2d.fromRadians(0), 0, 0, pose);
    }

    public DifferentialDriveWheelSpeeds getWheelSpeeds() {
        return new DifferentialDriveWheelSpeeds(this.leftEncoder.getRate(), this.rightEncoder.getRate());
    }

    public DifferentialDrive getDrive() {
        return this.drive;
    }

    public Field2d getField() {
        return this.field;
    }

    private void setSpeeds(DifferentialDriveWheelSpeeds speeds) {
        final double leftFeedforward = this.feedforward.calculate(speeds.leftMetersPerSecond);
        final double rightFeedforward = this.feedforward.calculate(speeds.rightMetersPerSecond);

        final double leftOutput = this.leftPIDController.calculate(this.leftEncoder.getRate(),
                speeds.leftMetersPerSecond);
        final double rightOutput = this.rightPIDController.calculate(this.rightEncoder.getRate(),
                speeds.rightMetersPerSecond);

        this.tankDriveVolts(leftOutput + leftFeedforward, rightOutput + rightFeedforward);
    }

    /**
     * Drives the robot with the given linear velocity and angular velocity.
     * 
     * @param linearSpeed Linear velocity in m/s.
     * @param rotation    Angular velocity in rad/s.
     */
    private void directDrive(double linearSpeed, double rotation) {
        var wheelSpeeds = Constants.DriveTrain.DriveKinematics
                .toWheelSpeeds(new ChassisSpeeds(linearSpeed, 0.0, rotation));
        this.setSpeeds(wheelSpeeds);
    }

    /**
     * Computes and publishes to a network tables topic the transformation from the
     * camera's pose to
     * the object's pose. This function exists solely for the purposes of
     * simulation, and this would
     * normally be handled by computer vision.
     *
     * <p>
     * The object could be a target or a fiducial marker.
     *
     * @param objectInField       The object's field-relative position.
     * @param robotToCamera       The transformation from the robot's pose to the
     *                            camera's pose.
     * @param cameraToObjectEntry The networktables entry publishing and querying
     *                            example computer
     *                            vision measurements.
     */
    private void publishCameraToObject(
            Pose3d objectInField,
            Transform3d robotToCamera,
            DoubleArrayEntry cameraToObjectEntry,
            DifferentialDrivetrainSim drivetrainSimulator) {
        Pose3d robotInField = new Pose3d(drivetrainSimulator.getPose());
        Pose3d cameraInField = robotInField.plus(robotToCamera);
        Transform3d cameraToObject = new Transform3d(cameraInField, objectInField);

        // Publishes double array with Translation3D elements {x, y, z} and Rotation3D
        // elements {w, x,
        // y, z} which describe
        // the cameraToObject transformation.
        double[] val = {
                cameraToObject.getX(),
                cameraToObject.getY(),
                cameraToObject.getZ(),
                cameraToObject.getRotation().getQuaternion().getW(),
                cameraToObject.getRotation().getQuaternion().getX(),
                cameraToObject.getRotation().getQuaternion().getY(),
                cameraToObject.getRotation().getQuaternion().getZ()
        };
        cameraToObjectEntry.set(val);
    }

    /**
     * Queries the camera-to-object transformation from networktables to compute the
     * robot's
     * field-relative pose from vision measurements.
     *
     * <p>
     * The object could be a target or a fiducial marker.
     *
     * @param objectInField       The object's field-relative pose.
     * @param robotToCamera       The transformation from the robot's pose to the
     *                            camera's pose.
     * @param cameraToObjectEntry The networktables entry publishing and querying
     *                            example computer
     *                            vision measurements.
     */
    private Pose3d objectToRobotPose(
            Pose3d objectInField, Transform3d robotToCamera, DoubleArrayEntry cameraToObjectEntry) {
        double[] val = cameraToObjectEntry.get();

        // Reconstruct cameraToObject Transform3D from networktables.
        Translation3d translation = new Translation3d(val[0], val[1], val[2]);
        Rotation3d rotation = new Rotation3d(new Quaternion(val[3], val[4], val[5], val[6]));
        Transform3d cameraToObject = new Transform3d(translation, rotation);

        return ComputerVisionUtil.objectToRobotPose(objectInField, cameraToObject, robotToCamera);
    }

    private void updateOdometry() {
        this.poseEstimator.update(
                this.gyro.getRotation2d(),
                this.leftEncoder.getDistance(),
                this.rightEncoder.getDistance());

        // Publish cameraToObject transformation to networktables --this would normally
        // be handled by the computer vision solution.
        publishCameraToObject(
                this.objectInField,
                Constants.Vision.RobotToTargetCamera,
                this.cameraToObjectEntry,
                this.driveSim);

        // Compute the robot's field-relative position exclusively from vision
        // measurements.
        Pose3d visionMeasurement3d = objectToRobotPose(
                this.objectInField,
                Constants.Vision.RobotToTargetCamera,
                this.cameraToObjectEntry);

        // Convert robot pose from Pose3d to Pose2d needed to apply vision measurements.
        Pose2d visionMeasurement2d = visionMeasurement3d.toPose2d();

        // Apply vision measurements. For simulation purposes only, we don't input a
        // latency delay -- on
        // a real robot, this must be calculated based either on known latency or
        // timestamps.
        this.poseEstimator.addVisionMeasurement(visionMeasurement2d, Timer.getFPGATimestamp());

    }
}
